---
title: Goland基础
date: 2025-03-06 21:25:02
permalink: /pages/dbcf37
categories:
  - 八股-goland
  - Goland八股
---

## Goland常识









### Goland有哪些数据类型？

:::note

值类型：基本数据类型都是值类型，包括：int系列、float系列、bool、字符串、数组、结构体struct。

引用类型：指针、切片slice、接口interface、管道channel以及map。

:::

>扩展1：值类型和引用类型的区别？

:::note

- 值类型在内存中存储的是值本身，而引用类型在内存中存储的是值的内存地址。
- 值类型内存通常在栈中分配，引用类型内存通常在堆中分配。

:::





## 基础面试题

### 1.new和make的区别？

new函数定义：

```go
func new(Type) *Type
```

- new函数只接受一个参数，这个参数是一个类型(Type)
- new函数返回一个指向该内存地址的指针(*Type)

```go
// example
func main() {
	a := new(int)
	b := new(bool)
	s := new([]int)

	fmt.Printf("%T\n", a) // *int
	fmt.Printf("%T\n", b) // *bool
	fmt.Printf("%T\n", s) // *[]int

	fmt.Println(*a) // 0
	fmt.Println(*b) // false
	fmt.Println(*s) // []，实际是nil，因为 Go 的 fmt 包对 nil slice 的显示是 []
}
```

make函数定义：

```go
func make(t Type, size ...IntegerType) Type
```

- make函数只能用于`slice`、`map`和`channel`的内存创建，返回的就是这三种类型本身而不是指针类型，因为这三种类型就是引用类型(指针类型)，所以没有必要返回它们的指针。  

```go
// example
func main() {
	s := make([]int, 2)
	fmt.Println(s) // [0 0]
	
	m := make(map[string]string)
	fmt.Println(m) // map[]，空 map

	c := make(chan int, 2)
	fmt.Println(c) // 0x14000138000
}
```



:::note

`make`和`new`都是用于分配内存的内建函数，但它们的使用场景和功能有所不同：

- `make`用于初始化并分配内存，只能用于`slice`、`map`和`channel`三种引用类型；
- `new`用于为任意类型分配内存，并将其置为**零值**，返回指向该内存的指针；
- `make`返回的是初始化后的类型本身（如 `[]int`），而new返回的是指向该内存的指针（如 `*int`）。

:::

### 2.数组和切片的区别？

1、数组长度固定，不能改变，数组长度是数组类型的一部分，不同长度的两个数组是两种不同类型；切片长度可变。

```go
var a [3]int   // 类型是 [3]int
var b [5]int   // 类型是 [5]int → 与 a 不兼容！
var s []int    // 类型是 []int，长度可变
```

2、数组是值类型，切片是引用类型。

```go
arr1 := [3]int{1, 2, 3}
arr2 := arr1          // 拷贝整个数组（修改 arr2 不影响 arr1）

slice1 := []int{1, 2, 3}
slice2 := slice1      // 共享底层数组（修改 slice2 可能影响 slice1）
```

3、slice的底层数据结构：

```go
// runtime/slice.go
type slice struct {
	array unsafe.Pointer  // 指向底层数组的指针（元素指针）
	len   int  // 长度
	cap   int  // 容量
}
```

![c52ceb85c1af5097c5ae60fb9431fc8d](https://blog-whalecoding.oss-cn-beijing.aliyuncs.com/picgo/20260121213529137.jpg)

slice实际上是一个结构体，包含三个字段：长度、容量、底层数组。

4、数组和切片的创建方式。

数组的创建使用字面量，切片的创建可以使用字面量/make/从数组生成。

```go
arr := [5]int{1, 2, 3, 4, 5}  // 数组：字面量

s1 := []int{1,2,3}  // 切片：字面量
s2 := make([]int, 2, 5)  // 切片：make
s3 := arr[1:4] // s3 是 []int{2,3,4}，底层数组是 arr
```

:::note

- 数组长度固定，不能改变，数组长度是数组类型的一部分，不同长度的两个数组是两种不同类型；切片长度可变，可以通过`append` 动态增加，切片统一类型，长度不参与类型定义。
- 数组底层是一块固定大小的连续内存，切片底层是一个结构体，包含三个字段：**长度、容量、底层数组**。
- 数组是**值类型**，传递时传的是复制的副本，不影响原数组；切片是**引用类型**，传递时会共享底层数组。
- 数组不能为`nil`，切片可以为`nil`；切片比数组更灵活。

:::

### 3.for range 的时候，它的地址会发生变化么？

在Go 1.22 之前的旧版本中，循环变量复用同一内存地址（地址不变），会导致闭包或取地址时可能出现问题。

在Go 1.22 及以后版本，循环变量在每次迭代时会获得新的内存地址，这从根本上解决了旧版本中闭包捕获同一变量地址的问题。

旧代码 (Go 1.22-):

```go
// 假设在 Go 1.21
for _, v := range mySlice {
    go func() { // 错误：捕获了循环变量的同一个地址
        fmt.Println(v)
    }()
}

```

解决方案 (适用于所有版本):

```go
for _, v := range mySlice {
    temp := v // 创建当前迭代的副本
    go func() {
        fmt.Println(temp) // 现在捕获的是副本
    }()
}
```

Go 1.22+ 示例 (地址会变):

```go
// 假设在 Go 1.22
for _, v := range mySlice {
    fmt.Println(&v) // 每次打印的地址都不同
}
```

:::note

- 在 **Go 1.22 之前**，`for range` 循环中的迭代变量，会复用同一内存地址（地址不变）；
- 在**Go 1.22 及以后版本**，循环变量在每次迭代时会获得新的内存地址（地址会变化）

:::

### 4.defer 的执行顺序是怎样的？defer 的作用或者使用场景是什么? 

1、可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反。

```go
func main() {
	defer fmt.Println(1)
	defer fmt.Println(2)
	defer fmt.Println(3)
}
// 输出：
// 3
// 2
// 1
```

实际用途：

```go
mu.Lock()
defer mu.Unlock()        // 最后加锁，最先解锁？不！
file, _ := os.Open(...)
defer file.Close()       // 先打开文件，后加锁 → 应该先关文件，再解锁？
```

2、当 defer 语句被执行时，跟在 defer 后面的函数会被延迟执行。

```go
func main() {
    defer fmt.Println("world")
    fmt.Println("hello")
}
// 输出：
// hello
// world
```

- `defer` 不会立即调用函数，而是将**函数调用（包括参数）压入一个栈**，等到当前函数退出时再执行。

3、直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。 

情况一：正常 return

```go
func main() {
	f()
}

func f() {
	defer fmt.Println("cleanup")
	return
}
// 会打印 "cleanup"
```

情况二：发生 panic

```go
func main() {
	g()
}

func g() {
	defer fmt.Println("cleanup")
	panic("error!")
}
// 先打印 "cleanup"，再 panic（因为 defer 在 panic 传播前执行）
```

4、`defer` 的典型用途。

```go
// 1.资源清理
f, _ := os.Open("file.txt")
defer f.Close()

// 2.解锁
mu.Lock()
defer mu.Unlock()

// 3.panic 恢复
func safeCall() {
    defer func() {
        if r := recover(); r != nil {
            log.Println("Recovered:", r)
        }
    }()
    riskyFunction()
}

// 4.函数执行时间统计
func foo() {
    start := time.Now()
    defer func() {
        fmt.Println("Duration:", time.Since(start))
    }()
    // ... 业务逻辑
}
```

:::note

defer是Go语言提供的关键字。defer用于资源的释放，会在函数返回之前进行调用。

如果有多个defer表达式，defer**执行顺序和声明顺序相反**，类似于栈后进先出(LIFO)。

<br>

defer 的作用：

当 defer 语句被执行时，跟在 defer 后面的函数会被延迟执行。

直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。 

<br>

defer 的常用场景:

- 资源清理；
- 解锁
- 函数执行时间统计

:::

### 5.什么是rune类型？





### 6.空struct{}占用空间吗？空struct{}有什么用？

:::note

1. Go语言中空struct{}**不占用空间**。
2. struct{}有如下作用：
   - 用map模拟一个set，可以把value置为struct{}，避免多余的内存分配
   - 给channel发送一个空结构体，可以节省空间
   - 表示仅有方法的结构体

:::

### 7.init()函数是什么时候执行的？





### 8.两个interface可以比较吗？



:::note

interface的内部实现包含2个字段，类型T和值V，2个interface可以比较。

2个interface相等有两种情况：

- 2个interface均等于nil(此时V和T都处于unset状态)
- 类型T相同，且对应的值V相等

:::



### Go多返回值怎么实现的？





### Go面向对象是如何实现的？





## Slice面试题

### 1.slice的底层结构是怎么样的？



### 2.slice的扩容机制 ？



### 3.从一个切片截取出另一个切片，修改新切片的值会影响原来的切片内容吗？



### 4.slice作为函数参数传递，会改变原slice吗？







## Map面试题

### 1.Map的底层实现原理？





### 2.Map的遍历是有序的还是无序的？







### 3.Map的遍历为什么要设计成无序的？



### 4.Map如何实现顺序读取？



### 5.Map是否是并发安全的？





### 6.Map的Key一定要是可比较的吗？为什么？





### 7.Map的扩容时机？扩容过程？



### 8.可以对Map的元素取地址吗？





### 9.Map 中删除一个 key，它的内存会释放么？



### 10.Map可以边遍历边删除吗





## Channel面试题

### 1.什么是CSP？



### 2.Channel的底层实现原理？



### 3.有缓冲channel和无缓冲channel的区别？

核心区别在于 **是否允许发送和接收操作在没有对方就绪的情况下“暂时”解耦**。





### 向channel发送数据的过程是怎样的？



### 从Channel读取数据的过程是怎样的？



### 从一个已关闭Channel仍能读出数据吗？





### Channel在什么情况下会引起内存泄漏？



### 关闭Channel会产生异常吗？





### 往一个关闭的Channel写入数据会发生什么？



## Select面试题

### select满足多个case的时候怎么执行的？











## Context面试题

### Context是什么？







### Context有什么作用？





### Context.Value的查找过程是怎样的？



### Context如何被取消？





## Interface面试题

### interface的底层原理？



### iface和eface的区别是什么？







## 反射面试题





什么是登录页？在导航栏 <mark>功能页 -> 登录页</mark> 点击查看效果。



<mark> 呜呜呜  </mark>



>www



::: note

这是一个笔记 Note 容器。

 :::

::: note 提醒 

这是一个笔记 Note 容器。

 :::



::: info
This is an info box.
:::

::: tip
This is a tip.
:::

::: warning
This is a warning.
:::

::: danger
This is a dangerous warning.

:::

::: details
This is a details block.
:::





::: danger STOP
危险区域，请勿继续
:::

::: details 点我查看代码
```js
console.log('Hello, VitePress!')
```
:::





- [x] 试试
- [x] 是是是
- [ ] 试试

```go
// 1. 两数之和
func main() {
	result := twoSum([]int{3, 3}, 6)
	fmt.Println(result)
}

func twoSum(nums []int, target int) []int {
	// 哈希表 key:数组中的值 value:值对应的数组索引
	hashMap := make(map[int]int) // 显式初始化哈希表（避免nil）
	// 遍历数组,获取需要的另一个数,如果map中存在这个数，则返回结果,否则将当前数加入map中
	for i, num := range nums {
		y := target - num // 需要的另一个数
		if _, ok := hashMap[y]; ok {
			// map中存在这个数，返回结果
			return []int{hashMap[y], i}
		}
		hashMap[num] = i // 记录当前值和在数组中的索引
	}
	return []int{} // 题目保证有解，返回空切片避免nil
}
```

**Teek 是一个轻量**、简洁高效、灵活配置、易于扩展的 **`VitePress`** 主题 ✨，是在默认主题的基础上进行拓展，支持 `VitePress` 的所有功能、配置，完全可以零成本迁移过来。

<!--滴答滴答滴答滴答-->

使用 Teek可以很方便的搭建一个结构化的知识库或博客。

::: warning

- Node.js `18.0.0` 及以上版本
- 在使用 Teek 前，要求至少会 VitePress 的基本使用和默认主题的基本配置，然后再查看本文档
- 本文档仅负责介绍 Teek 对 VitePress 默认主题的扩展部分，VitePress 自带配置请移步 [VitePress 中文文档](https://vitepress.dev/zh/)

:::



## 代码组



可以像这样对多个代码块进行分组：

::: code-group

```js [config.js]
/**
 * @type {import('vitepress').UserConfig}
 */
const config = {
  // ...
}

export default config
```

```ts [configddd.cs]
import type { UserConfig } from 'vitepress'

const config: UserConfig = {
  // ...
}

export default config
```

:::







## 特性

> **知识管理**

包含三种典型的知识管理形态：结构化、碎片化、体系化。轻松打造属于你自己的知识管理平台。

> **结构化 & 体系化**

自动生成侧边栏、目录页、索引页、面包屑等，轻松构建一个结构化知识库。

> **碎片化 & 个性化**

博客功能提供快速构建知识的碎片化形态，并提供大量个性化的主题配置。

> **文档风 & 博客风**

支持通过配置随意切换文档风和博客风，支持个人博客、文档站、知识库等场景。

## 拓展功能

相较于 VitePress 主题，Teek 主要实现了博客风格的功能，这些功能也兼容文档风格，您现在正在阅读的是 Teek 的文档风格。

> 全局

- 侧边栏自动生成，根据目录自动生成侧边栏，无需手动配置
- 提供目录页，根据 `Markdown` 文件路径自动生成目录
- 自动生成 `frontmatter`，并且支持拓展 `frontmatter` 格式
- 自动生成一级标题
- 全站背景图片
- `Markdown` 拓展：居中、居右容器、卡片容器、`Demo` 容器、`TODO` 列表、`Video` 容器
- 主题多元化：4 种布局模式、8 种主题风格选择，且支持自定义扩展新的主题风格
- 移动端适配：自动适配移动端
- ...

> 首页

- `Banner` 功能：提供 3 种风格选择：局部背景色、局部图片、全屏图片，提供打印个性签名、切换个性签名选择，提供 `Feature` 功能
- 文章列表：支持切换列表和卡片模式，展示文章标题、封面图、作者、创建时间、更新时间、标签、分类，且支持重写文章列表
- 博客卡片栏：博主信息栏、精选文章栏、分类栏、标签栏、友情链接栏、站点信息栏
- 全屏壁纸模式：只保留 `Banner` 背景图片或全站背景图片，且禁止滚动、打开开发者工具、右键功能
- 页脚：展示社交图标、版权信息、备案信息、自定义信息
- ...

> 文章页

- 文章信息：展示面包屑、作者、创建时间、更新时间、标签、分类、字数、阅读时长
- 评论区：提供 `Giscus`、`Twikoo`、`Waline`、`Artalk` 四种评论提供商选择，并且支持自定义评论区
- 代码块：UI 升级，支持一键折叠/展开
- 文章页风格书页化：提供 3 种风格选择：VitePress 原生、整体卡片化、片段卡片化
- 文章打赏：支持 3 种打赏风格选择
- 文章分享：提供一键复制文章链接功能
- 最近更新栏：展示最近更新文章
- ...

> 功能页

- 分类页
- 标签页
- 归档页
- 清单页
- 登录页
- 风险链接提示页

除了上述功能，Teek 也提供了各种 `CSS` 文件来增强 VitePress 的样式，并提供大量的插槽支持二次开发。

如果您是其他主题的用户，也可以按需引入 Teek 的功能，增强自己的站点风格。
