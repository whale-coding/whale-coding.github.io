---
title: 数据结构
date: 
permalink: 
categories:
---

### 1.B树和B+树的区别？





### 2.快排的思想？



### 3.栈、队列的特点以及使用场景？





### 4.红黑树的特点？



### 5.红黑树和二叉树的区别？



### 6.B+树和B树(B-树)的区别？



### 7.广度优先搜索和深度优先搜索的区别？

:::note

广度优先搜索是从某一节点开始，搜索与其线连接的所有节点，按照广度方向外扩展，直到不重复遍历所有节点。 深度优先搜索是从某一节点开始，沿着其搜索到的第一个节点不断深入下去，当无法再深入的时候，回溯节点。

广度优先搜索是一层层进行遍历的，需要用到<mark>队列</mark>。深度优先搜索用<mark>栈或者递归</mark>来实现。

:::

### 8.冒泡排序的基本思想？时间复杂度是多少？

```java
// 基础版冒泡排序
public static void bubbleSort(int[] arr) {
    int n = arr.length;
    // 外层循环：控制总共需要比较的轮数
    for (int i = 0; i < n - 1; i++) {
        // 内层循环：每次比较相邻的两个元素
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换 arr[j] 和 arr[j+1]
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
     
    
// 优化的冒泡排序：用 swapped 提前退出。
public static void bubbleSort(int[] arr) {
    int n = arr.length;
    // 外层循环：控制总共需要比较的轮数
    for (int i = 0; i < n - 1; i++) {
        boolean swapped = false; // 标记本轮是否发生交换
        // 内层循环：两两比较，把大的元素逐步“冒”到末尾
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换 arr[j] 和 arr[j+1]
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        // 如果本轮没有发生交换，说明数组已经有序，提前结束
        if (!swapped) {
            break;
        }
    }
}
```

:::note

冒泡排序的核心思想是： **比较相邻元素并交换，使较大的元素逐步“冒”到数组末尾。**

- 最好情况：数组本来就是有序的，只需一趟遍历，无交换，复杂度 `O(n)`。
- 最坏情况：数组逆序，每次都要交换，复杂度 `O(n²)`。
- 平均情况：`O(n²)`

:::
