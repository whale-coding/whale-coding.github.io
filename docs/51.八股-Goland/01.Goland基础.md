---
title: Goland基础
date: 2025-03-06 21:25:02
permalink: /pages/dbcf37
categories:
  - 八股-goland
  - Goland八股
---

## Goland常识

### 1.与其他语言相比，使用 Go 有什么好处?

:::note

Go语言是Google在2019年开源的一种<mark>静态强类型、编译型语言</mark>，设计目标是“**兼具Python 等动态语言的开发速度和C/C++等编译型语言的性能与安全性**”。

以下是 Go 语言与其他语言相比的具体好处：

- 天然并发支持: 通过 goroutine（轻量级线程）和 channel（CSP 模型），开发者能以极低成本编写高并发程序。
- 简洁易学: 语法极其精简， 代码风格统一，上手快，开发效率高。
- 高性能与低资源占用: Go编译为本地机器码，启动快、内存占用少，远优于 Java（无需 JVM）和 Python（无解释器开销）。

与 Java 相比，Go 启动快、资源占用少；与 Python 相比，Go 拥有编译型的类型安全和高性能。

:::

### 2.Java和Go的区别？

:::note

1. 设计理念:Java 是企业级、功能丰富的语言，强调“一次编写，到处运行”，生态庞大但相对重量级；Go 则奉行“少即是多”，语法极简，标准库强大，强调可读性、部署便捷性和高并发支持。
2. 编程范式:Java 以面向对象为核心；Go 采用<mark>组合优于继承</mark>的 OOP 风格，通过结构体组合和接口实现多态和代码复用。
3. 运行部署:Java 依赖 JVM，跨平台但启动慢、内存占用高；Go直接编译为机器码，无需JVM，部署简便，运行效率高。
4. 并发模型:Go通过Goroutine和Channel实现轻量级并发，开销极低；Java通常使用线程池，较重，虽有虚拟线程但不如Go原生。
5. 内存管理:两者皆有垃圾回收，Java GC 种类多，可调优但复杂；Go 使用**低延迟、并发 GC**。
6. 指针:Java中不存在显式的指针，而Go中存在显式的指针操作。
7. 异常处理:Java 使用异常机制，Go 显式返回 error，鼓励“显式检查”。
8. 使用场景:Java适合大型电商系统、Android开发、复杂业务逻辑企业应用；Go适合云原生、网络编程、高性能微服务、高并发中间件。 

:::



### 3.Go有哪些数据类型？

:::note

值类型：基本数据类型（如int、float、complex、bool、string）、数组、结构体(struct)。

引用类型：slice、map、channel、interface、function、pointers。

:::

>扩展1：值类型和引用类型的区别？

:::danger NOTE

- 值类型在内存中存储的是值本身，而引用类型在内存中存储的是值的内存地址。
- 值类型内存通常在栈中分配，引用类型内存通常在堆中分配。

:::

### 4.Go语言中打印字符串时，%v 、%+v和 %#v 的区别？

```go
// example
type student struct {
	id   int32
	name string
}

func main() {
	a := &student{id: 1, name: "张三"}
	fmt.Printf("a=%v  \n", a)  // a=&{1 张三}
	fmt.Printf("a=%+v  \n", a) // a=&{id:1 name:张三}
	fmt.Printf("a=%#v  \n", a) // a=&main.student{id:1, name:"张三"}
}
```

:::note

在Go语言中，主要区别在于打印结构体的效果不同：

- `%v` 只输出结构体变量的值；

- `%+v` 先输出结构体成员字段名，再输出该字段的值；
- `%#v` 先输出结构体名称，再输出结构体内容（即结构体成员字段名+对应的值）；

:::

### 5.Go语言中如何高效地拼接字符串？

拼接字符串的方式有5种：

`+`、`fmt.Sprintf`、`strings.Builder`、`bytes.Buffer`、`strings.Join`。

1.`+`

使用`+`操作符进行拼接时，会对字符串进行遍历，计算并开辟一个新的空间来存储原来的两个字符串。

2.`fmt.Sprintf`

由于采用了接口参数，必须要用反射获取值，因此有性能损耗。

3.`strings.Builder`

用`WriteString()`进行拼接，内部实现是指针+切片，同时`String()`返回拼接后的字符串，它是直接把`[]byte`转换为`string`，从而避免变量拷贝。

4.`bytes.Buffer`

`bytes.Buffer`是一个一个缓冲`byte`类型的缓冲器，这个缓冲器里存放着都是`byte`，`bytes.buffer`底层也是一个`[]byte`切片。

5.`strings.Join`

`strings.join`也是基于`strings.builder`来实现的,并且可以自定义分隔符，在join方法内调用了`b.Grow(n)`方法，这个是进行初步的容量分配，而前面计算的n的长度就是我们要拼接的slice的长度，因为我们传入切片长度固定，所以提前进行容量分配可以减少内存分配，很高效。

性能比较：<mark>strings.Join ≈ strings.Builder > bytes.Buffer > "+" > fmt.Sprintf</mark>

```go
func main() {
	a := []string{"a", "b", "c"}
	
	// 方式1：+
	ret := a[0] + a[1] + a[2]
	
	// 方式2：fmt.Sprintf
	ret := fmt.Sprintf("%s%s%s", a[0], a[1], a[2])
	
	// 方式3：strings.Builder
	var sb strings.Builder
	sb.WriteString(a[0])
	sb.WriteString(a[1])
	sb.WriteString(a[2])
	ret := sb.String()
	
	// 方式4：bytes.Buffer
	buf := new(bytes.Buffer)
	buf.Write([]byte(a[0]))
	buf.Write([]byte(a[1]))
	buf.Write([]byte(a[2]))
	ret := buf.String()
	
	// 方式5：strings.Join
	ret := strings.Join(a, "")
}
```

:::note

在Go语言中，拼接字符串的方式有5种：

`+`、`fmt.Sprintf`、`strings.Builder`、`bytes.Buffer`、`strings.Join`。

:::

### 6.Go 语言 tag 有什么用？

参考资料：https://www.mianshiya.com/bank/1810641215871569922/question/1810649487023038466#heading-6

:::note

tag可以为结构体成员提供属性。常见的：

- `json`序列化或反序列化时字段的名称
- `db: sqlx`模块中对应的数据库字段名
- `form: gin`框架中对应的前端的数据字段名
- `binding`: 搭配 form 使用, 默认如果没查找到结构体中的某个字段则不报错值为空, binding为 required 代表没找到返回错误给前端

:::

### 7.Go语言中"_"的作用？

:::note

- 忽略多返回值：在 Go 语言中，函数可以返回多个值。对于不需要的返回值，就可以用 `_` 来忽略.
- 当导入一个包，如果只想执行包的 `init()` 函数而不需要直接使用包中的任何导出成员。这时可以使用 `_` 来进行**匿名导入**。

:::

### 8.Go面向对象是如何实现的？

:::note 参考答案

Go 没有传统意义上“类/继承”的面向对象，但它用 **struct + method + interface + 组合** 把 OOP 的核心能力都实现了，而且更偏“组合优于继承”。

:::

## 基础面试题

### 1.new和make的区别？

new函数定义：

```go
func new(Type) *Type
```

- new函数只接受一个参数，这个参数是一个类型(Type)
- new函数返回一个指向该内存地址的指针(*Type)

```go
// example
func main() {
	a := new(int)
	b := new(bool)
	s := new([]int)

	fmt.Printf("%T\n", a) // *int
	fmt.Printf("%T\n", b) // *bool
	fmt.Printf("%T\n", s) // *[]int

	fmt.Println(*a) // 0
	fmt.Println(*b) // false
	fmt.Println(*s) // []，实际是nil，因为 Go 的 fmt 包对 nil slice 的显示是 []
}
```

make函数定义：

```go
func make(t Type, size ...IntegerType) Type
```

- make函数只能用于`slice`、`map`和`channel`的内存创建，返回的就是这三种类型本身而不是指针类型，因为这三种类型就是引用类型(指针类型)，所以没有必要返回它们的指针。  

```go
// example
func main() {
	s := make([]int, 2)
	fmt.Println(s) // [0 0]
	
	m := make(map[string]string)
	fmt.Println(m) // map[]，空 map

	c := make(chan int, 2)
	fmt.Println(c) // 0x14000138000
}
```



:::note

`make`和`new`都是用于分配内存的内建函数，但它们的使用场景和功能有所不同：

- `make`用于初始化并分配内存，只能用于`slice`、`map`和`channel`三种引用类型；
- `new`用于为任意类型分配内存，并将其置为**零值**，返回指向该内存的指针；
- `make`返回的是初始化后的类型本身（如 `[]int`），而new返回的是指向该内存的指针（如 `*int`）。

:::

### 2.数组和切片的区别？

1、数组长度固定，不能改变，数组长度是数组类型的一部分，不同长度的两个数组是两种不同类型；切片长度可变。

```go
var a [3]int   // 类型是 [3]int
var b [5]int   // 类型是 [5]int → 与 a 不兼容！
var s []int    // 类型是 []int，长度可变
```

2、数组是值类型，切片是引用类型。

```go
arr1 := [3]int{1, 2, 3}
arr2 := arr1          // 拷贝整个数组（修改 arr2 不影响 arr1）

slice1 := []int{1, 2, 3}
slice2 := slice1      // 共享底层数组（修改 slice2 可能影响 slice1）
```

3、slice的底层数据结构：

```go
// runtime/slice.go
type slice struct {
	array unsafe.Pointer  // 指向底层数组的指针（元素指针）
	len   int  // 长度
	cap   int  // 容量
}
```

![c52ceb85c1af5097c5ae60fb9431fc8d](https://blog-whalecoding.oss-cn-beijing.aliyuncs.com/picgo/20260121213529137.jpg)

slice实际上是一个结构体，包含三个字段：长度、容量、底层数组。

4、数组和切片的创建方式。

数组的创建使用字面量，切片的创建可以使用字面量/make/从数组生成。

```go
arr := [5]int{1, 2, 3, 4, 5}  // 数组：字面量

s1 := []int{1,2,3}  // 切片：字面量
s2 := make([]int, 2, 5)  // 切片：make
s3 := arr[1:4] // s3 是 []int{2,3,4}，底层数组是 arr
```

:::note

- 数组长度固定，不能改变，数组长度是数组类型的一部分，不同长度的两个数组是两种不同类型；切片长度可变，可以通过`append` 动态增加，切片统一类型，长度不参与类型定义。
- 数组底层是一块固定大小的连续内存，切片底层是一个结构体，包含三个字段：**长度、容量、底层数组**。
- 数组是**值类型**，传递时传的是复制的副本，不影响原数组；切片是**引用类型**，传递时会共享底层数组。
- 数组不能为`nil`，切片可以为`nil`；切片比数组更灵活。

:::

### 3.for range 的时候，它的地址会发生变化么？

在Go 1.22 之前的旧版本中，循环变量复用同一内存地址（地址不变），会导致闭包或取地址时可能出现问题。

在Go 1.22 及以后版本，循环变量在每次迭代时会获得新的内存地址，这从根本上解决了旧版本中闭包捕获同一变量地址的问题。

旧代码 (Go 1.22-):

```go
// 假设在 Go 1.21
for _, v := range mySlice {
    go func() { // 错误：捕获了循环变量的同一个地址
        fmt.Println(v)
    }()
}

```

解决方案 (适用于所有版本):

```go
for _, v := range mySlice {
    temp := v // 创建当前迭代的副本
    go func() {
        fmt.Println(temp) // 现在捕获的是副本
    }()
}
```

Go 1.22+ 示例 (地址会变):

```go
// 假设在 Go 1.22
for _, v := range mySlice {
    fmt.Println(&v) // 每次打印的地址都不同
}
```

:::note

- 在 **Go 1.22 之前**，`for range` 循环中的迭代变量，会复用同一内存地址（地址不变）；
- 在**Go 1.22 及以后版本**，循环变量在每次迭代时会获得新的内存地址（地址会变化）

:::

### 4.defer 的执行顺序是怎样的？defer 的作用或者使用场景是什么? 

1、可以在一个函数中执行多条 defer 语句，它们的执行顺序与声明顺序相反。

```go
func main() {
	defer fmt.Println(1)
	defer fmt.Println(2)
	defer fmt.Println(3)
}
// 输出：
// 3
// 2
// 1
```

实际用途：

```go
mu.Lock()
defer mu.Unlock()        // 最后加锁，最先解锁？不！
file, _ := os.Open(...)
defer file.Close()       // 先打开文件，后加锁 → 应该先关文件，再解锁？
```

2、当 defer 语句被执行时，跟在 defer 后面的函数会被延迟执行。

```go
func main() {
    defer fmt.Println("world")
    fmt.Println("hello")
}
// 输出：
// hello
// world
```

- `defer` 不会立即调用函数，而是将**函数调用（包括参数）压入一个栈**，等到当前函数退出时再执行。

3、直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。 

情况一：正常 return

```go
func main() {
	f()
}

func f() {
	defer fmt.Println("cleanup")
	return
}
// 会打印 "cleanup"
```

情况二：发生 panic

```go
func main() {
	g()
}

func g() {
	defer fmt.Println("cleanup")
	panic("error!")
}
// 先打印 "cleanup"，再 panic（因为 defer 在 panic 传播前执行）
```

4、`defer` 的典型用途。

```go
// 1.资源清理
f, _ := os.Open("file.txt")
defer f.Close()

// 2.解锁
mu.Lock()
defer mu.Unlock()

// 3.panic 恢复
func safeCall() {
    defer func() {
        if r := recover(); r != nil {
            log.Println("Recovered:", r)
        }
    }()
    riskyFunction()
}

// 4.函数执行时间统计
func foo() {
    start := time.Now()
    defer func() {
        fmt.Println("Duration:", time.Since(start))
    }()
    // ... 业务逻辑
}
```

:::note

defer是Go语言提供的关键字。defer用于资源的释放，会在函数返回之前进行调用。

如果有多个defer表达式，defer**执行顺序和声明顺序相反**，类似于栈后进先出(LIFO)。

<br>

defer 的作用：

当 defer 语句被执行时，跟在 defer 后面的函数会被延迟执行。

直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。 

<br>

defer 的常用场景:

- 资源清理；
- 解锁
- 函数执行时间统计

:::

### 5.什么是rune类型？

Go语言中的`byte`和`rune`是用于处理字符和字符串的两种核心数据类型。`byte`（`uint8`的别名）代表单个字节，适用于ASCII字符和原始数据处理。`rune`（`int32`的别名）代表一个UTF-8编码的Unicode代码点，适用于处理多字节的中文字符或国际化文本。 

```go
type byte = uint8
type rune = int32
```

![image-20260123175054799](https://blog-whalecoding.oss-cn-beijing.aliyuncs.com/picgo/20260123175055021.png)

```go
func main() {
	var str = "hello 你好"

	// golang中string底层是通过byte数组实现的，直接求len 实际是在按字节长度计算
	// 在 Go 语言中，一个中文字符通常占用 3 个字节，因为 Go 的字符串默认使用 UTF-8 编码格式
	// 在 UTF-8 编码中，绝大多数常用汉字被编码为 3 字节，英文数字则占 1 字节。
	fmt.Println("len(str):", len(str)) // len(str): 12

	// 通过rune类型处理 unicode字符，再求len 就是按字符长度计算
	fmt.Println("rune:", len([]rune(str))) // rune: 8
}
```

:::note

Go 语言的字符有两种，一种是`byte`类型，另一种是`rune`类型。

- `byte`是`uint8`的别名，代表 ASCII 码的一个字符。
- `rune`是 `int32` 的别名，代表一个 Unicode 码点。它通常用单引号定义，专门用于处理 UTF-8 编码的 Unicode 字符，能够处理包含中文在内的复杂字符。

场景：

- `byte`用于处理二进制数据和文件读取场景。
- 当需要遍历字符串中的每一个字符（如统计中文字符个数）或处理字符串索引时，应将 `string` 转换为 `[]rune`。

:::

>扩展面试题：byte和rune的区别？

:::danger NOTE

`byte` 是 `uint8` 的别名，代表 ASCII 字符或 UTF-8 编码的一个字节；`rune`是 `int32` 的别名，代表一个完整的字符。

:::

### 6.空struct{}占用空间吗？空struct{}有什么用？

:::note

1. Go语言中空struct{}**不占用空间**。
2. struct{}有如下作用：
   - 用map模拟一个set，可以把value置为struct{}，避免多余的内存分配
   - 给channel发送一个空结构体，可以节省空间
   - 表示仅有方法的结构体

:::

### 7.Go语言中init()函数是什么时候执行的？

![image-20260123185921833](https://blog-whalecoding.oss-cn-beijing.aliyuncs.com/picgo/20260123185921963.png)

`init()`函数在Go程序执行之前自动调用，<mark>会在main()函数执行之前执行</mark>。

`init()`函数主要作用：包的初始化操作，如初始化全局变量、检查程序状态等。

`init()`函数没有入参和返回值，不能被其他函数显示调用，每个包可以有多个`init()`函数，且只会被执行一次。 

具体执行顺序：

<mark>import –> const –> var –>init()–>main()</mark>

每个包首先初始化包作用域的常量、包作用域的变量，然后执行包的`init()`函数。在同一包中，多个`init()` 函数以文件名字母顺序依次调用，同一个文件内的多个`init()`函数则是以出现的顺序依次调用。最终在`main()`函数开始执行之前，所有相关包的`init`函数都已经执行完毕。

:::note

<mark>init()函数在main()函数之前执行</mark>，由运行时自动调用。

初始化顺序遵循：<mark>导入包(import) -> 常量(const) -> 变量(var) -> init() -> main()</mark>。

1. `init()` 在包被导入时自动执行，用于初始化包级别的变量、设置配置等。 `init()` 函数没有参数，也没有返回值，只会被执行一次，不能被其他函数显式调用。

2. 在一个包中，首先初始化常量和变量（常量优先），然后执行 `init()` 函数。如果包A导入了包B，那么包B的 `init()` 会先于包A的 `init()` 执行。

3. 同一个包中可以有多个 `init()` 函数，按按文件名的字典序依次执行。若同一文件中存在多个 `init()`，则按从上到下的顺序执行。所有 `init()` 均在 `main()` 函数前完成。  

:::

### 8.Go多返回值怎么实现的？

Go语言的多返回值是通过**栈**内存传递实现的。在函数调用时，调用者（Caller）会在自己的栈帧上预留出足够的空间来存储被调用者（Callee）的所有返回值，被调用者执行时会将结果直接写入调用者栈帧中对应的空间，从而高效地实现了多个值的返回。 

这里设计到FP和SP，比较底层！！！

Go 语言的多返回值是通过在函数调用栈帧上预留空间并进行**值复制**来实现的。在函数调用发生时，Go 编译器会计算出函数所有返回值的总大小。在为该函数创建**栈帧**时，就会在调用方（caller）的栈帧上，为这些返回值预留出连续的内存空间。

当函数执行到 `return` 语句时，它会将其要返回的各个值**复制**到这些预留好的栈空间中。函数执行完毕后，控制权返回给调用方。此时，调用方可以直接从它自己的栈帧上（即之前为返回值预留的空间）获取这些返回的值。

:::note



:::

>扩展面试题：Go的多值返回有什么用？

:::danger NOTE

简化代码：减少为返回多个值而创建的临时结构体；

错误处理：在函数中返回值的同时返回错误信息，从而更好的进行错误处理；

提高可读性：多值返回可以使返回值类型更清晰，避免结构体等嵌套结构。

:::

### 9.Go函数传参是值类型还是引用类型？

:::note

Go语言中所有的函数参数传递都是**值传递**。传递的是参数的副本，要么是值的副本，要么是指针的副本。

值类型如 `int`, `string`, `struct`, `array`传递的副本是独立数据，修改它不会影响原数据。

引用类型/指针如 `map`, `slice`, `channel`, `指针` 传递的副本指向相同的底层内容，修改内部元素会影响原数据。

:::

### 10.如何知道一个对象是分配在栈上还是堆上？

:::note

Go局部变量会进行**逃逸分析**。如果变量离开作用域后没有被引用，则优先分配到栈上，否则分配到堆上。

在Go中可使用 `go build -gcflags '-m' xxx.go`  查看逃逸分析结果，确定是分配在栈上还是堆上。

:::

### 11.Go普通指针和unsafe.Pointer有什么区别？

:::note

- 普通指针有明确的类型信息，是类型安全且受GC管理的，禁止指针算术运算，不同类型的指针之间不能直接转换，仅能指向特定类型。
- `unsafe.Pointer`是Go的通用指针类型，允许绕过类型系统，可以与任意类型的指针相互转换，也可以与`uintptr`进行转换来做指针运算。

:::

### 12.unsafe.Pointer与uintptr有什么区别和联系？

`unsafe.Pointer`和`uintptr`可以相互转换，这是Go提供的唯一合法的指针运算方式。典型用法是先将`unsafe.Pointer`转为`uintptr`做算术运算，然后再转回`unsafe.Pointer`使用。

最关键的区别在于**GC跟踪**。`unsafe.Pointer`会被垃圾回收器跟踪，它指向的内存不会被错误回收；而`uintptr`只是一个普通整数，GC完全不知道它指向什么，如果没有其他引用，对应内存可能随时被回收。

所以记住：`unsafe.Pointer`有GC保护，`uintptr`没有，这是它们最本质的区别。

![image-20260123205355324](https://blog-whalecoding.oss-cn-beijing.aliyuncs.com/picgo/20260123205355466.png)

联系与协同工作：

1. 转换桥梁：任何指针类型均可转换为`unsafe.Pointer`，`unsafe.Pointer`也可转换为任何指针类型。
2. 相互转换：`unsafe.Pointer`可转换为`uintptr`进行算术运算，随后再转回`unsafe.Pointer`访问内存。
3. 协同模式：常用作“指针 -> `unsafe.Pointer` -> `uintptr` (偏移运算) -> `unsafe.Pointer` -> 指针”的转换链。 

使用注意事项：`uintptr`不被GC管理，在将`uintptr`转回`unsafe.Pointer`之前，原始指针必须保持存活，否则可能指向被回收的内存。

:::note

- `unsafe.Pointer`是通用指针类型，用于在不同指针类型间转换并受GC保护，不支持指针算术运算；
- `uintptr`是整数类型，专门用于指针算术运算，不受GC追踪。

:::



## Slice面试题

### 1.slice的底层结构是怎么样的？

slice 的底层数据其实也是数组，slice 是对数组的封装，它描述一个数组的片段。slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。

```go
// runtime/slice.go
type slice struct {
	array unsafe.Pointer // 指向底层数组的指针
	len   int // 切片当前长度
	cap   int // 切片底层数组的容量
}
```

![c52ceb85c1af5097c5ae60fb9431fc8d](https://blog-whalecoding.oss-cn-beijing.aliyuncs.com/picgo/20260121213529137.jpg)

切片的长度是它所包含的元素个数。切片的容量是从它的第一个元素到其底层数组元素末尾的个数。切片 `s` 的长度和容量可通过表达式 `len(s)` 和 `cap(s)` 来获取。

```go
func main() {
	s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} // 切片初始化，同时创建一个长度为5的数组
	// [0 1 2 3 4 5 6 7 8 9] 10 10
	fmt.Println(s, len(s), cap(s))

	s1 := s[0:5]
	// [0 1 2 3 4 5] 5 10
	fmt.Println(s1, len(s1), cap(s1))

	// [5 6 7 8 9] 5 5
	s2 := s[5:]
	fmt.Println(s2, len(s2), cap(s2))
}
```

:::note

切片底层是一个结构体，由3部分构成：指向底层数组的指针、长度和容量。

切片长度指的是切片当前包含的元素个数，即可以通过切片名访问的元素数量。

切片容量指的是从切片起始元素到底层数组末尾的元素个数。

:::

### 2.slice的扩容机制 ？

`slice` 通过调用 `append` 函数来针对`slice`进行尾部追加元素，如果此时 `slice` 的 `cap` 值小于当前 `len` 加上 `append` 中传入值的数量，就会调用 `runtime.growslice` 函数，进行扩容。

Go1.18 之前的扩容规则:

```go
// 简化版 runtime.growslice 逻辑 (1.18-)
// runtime/slice.go
func growslice(et *_type, old slice, cap int) slice {
    newcap := old.cap
    doublecap := newcap + newcap
    // 如果新容量大于旧容量的两倍，则直接按照新容量大小申请
    if cap > doublecap {
			newcap = cap
    } else {
        // 如果原有长度小于1024，则新容量是旧容量的2倍
        if old.len < 1024 {
            newcap = doublecap
        } else {
            // 按照原有容量的 1/4 增加，直到满足新容量的需要
            for 0 < newcap && newcap < cap {
                newcap += newcap / 4
            }
            if newcap <= 0 {
                newcap = cap
            }
        }
    }
}
```

- 如果期望容量大于当前容量的两倍就会使用期望容量；
- 如果当前切片的长度小于 1024 就会将容量翻倍；
- 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；

Go1.18及以后，新的扩容规则：

```go
// 简化版 runtime.growslice 逻辑 (1.18+)
// runtime/slice.go
threshold := 256
newcap := oldcap
doublecap := newcap + newcap

if cap > doublecap {
  	// 如果新容量大于旧容量的两倍，则直接按照新容量大小申请
    newcap = cap
} else {
  	// 如果当前切片的长度小于阈值就会将容量翻倍；
    if oldcap < threshold {
        newcap = doublecap
    } else {
        // 阈值以上平滑增长
        for 0 < newcap && newcap < cap {
            // 每次增加 25% 加上一个平滑项
            newcap += (newcap + 3*threshold) / 4
        }
        // 如果newcap溢出，则修正为请求的cap
        if newcap <= 0 {
            newcap = cap
        }
    }
}

```

- 如果期望容量大于当前容量的两倍就会使用期望容量；
- 如果当前切片的长度小于阈值（默认 256）就会将容量翻倍；
- 如果当前切片的长度大于等于阈值（默认 256），就会每次增加 25% 的容量，基准是 `newcap + 3*threshold`，直到新容量大于期望容量；

参考资料：

https://developer.aliyun.com/article/1509760

:::note

当 `append` 的新元素导致 `len > cap` 时，触发扩容。slice扩容时会调用`runtime.growslice`函数。

Go1.18 之前的扩容规则:

- 如果期望容量大于当前容量的两倍就会使用期望容量；
- 如果当前切片的长度小于 1024 就会将容量翻倍；
- 如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；

Go1.18及之后的扩容规则：

- 如果期望容量大于当前容量的两倍就会使用期望容量；
- 如果当前切片的长度小于阈值（默认 256），新容量 = 旧容量 *2；
- 如果当前切片的长度大于等于阈值（默认 256），新容量 = 旧容量+（3*旧容量+阈值256）/4 ，直到新容量大于期望容量；

:::

### 3.从一个切片截取出另一个切片，修改新切片的值会影响原来的切片内容吗？

```go
func main() {
	slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	s1 := slice[2:5]
	s2 := s1[2:6:7]

	s2 = append(s2, 100)
	s2 = append(s2, 200)

	s1[2] = 20

	fmt.Println(s1)    // Output: [2 3 20]
	fmt.Println(s2)    // Output: [20 5 100 200]
	fmt.Println(slice) // Output: [0 1 2 3 20 100 200 7 8 9]
}
```

:::note

在截取完之后，如果新切片没有触发扩容，则修改切片元素会影响原切片，如果触发了扩容则不会。

:::

### 4.slice作为函数参数传递，会改变原slice吗？

:::note

slice 本身是一个结构体(指针 + len + cap)当 slice 作为函数参数时，传入的是这个结构体的**副本**。

所以原来的 slice 结构不会改变，但<mark>副本中的指针仍指向原底层数组</mark>，

- 修改 slice 中的元素值会影响原slice;
- 当slice副本进行<mark>append且发生扩容</mark>时，不影响原 slice;
- 若传的是 slice 的指针，则原 slice 结构会变，底层数组的数据也会变。

:::

## Map面试题

### 1.Map的底层实现原理？

hmap结构定义：

```go
// A header for a Go map.
type hmap struct {
   count     int// map中元素个数
   flags     uint8// 状态标志位，标记map的一些状态
   B         uint8// 桶数以2为底的对数，即B=log_2(len(buckets))，比如B=3，那么桶数为2^3=8
   noverflow uint16//溢出桶数量近似值
   hash0     uint32// 哈希种子

   buckets    unsafe.Pointer // 指向buckets数组的指针
   oldbuckets unsafe.Pointer // 是一个指向buckets数组的指针，在扩容时，oldbuckets 指向老的buckets数组(大小为新buckets数组的一半)，非扩容时，oldbuckets 为空
   nevacuate  uintptr        // 表示扩容进度的一个计数器，小于该值的桶已经完成迁移

   extra *mapextra // 指向mapextra 结构的指针，mapextra 存储map中的溢出桶
}
```



### 2.Map的遍历是有序的还是无序的？

:::note

Map的遍历是无序的。map每次遍历,都会从一个随机值序号的桶,在每个桶中，再从按照之前选定随机槽位开始遍历,所以是无序的。

:::





### 3.Map的遍历为什么要设计成无序的？



### 4.Map如何实现顺序读取？



### 5.Map是否是并发安全的？





### 6.Map的Key一定要是可比较的吗？为什么？





### 7.Map的扩容时机？扩容过程？



### 8.可以对Map的元素取地址吗？





### 9.Map 中删除一个 key，它的内存会释放么？



### 10.Map可以边遍历边删除吗



### 11.Go语言如何实现Set?



## Channel面试题

### 1.什么是CSP？



### 2.Channel的底层实现原理？



### 3.有缓冲channel和无缓冲channel的区别？

核心区别在于 **是否允许发送和接收操作在没有对方就绪的情况下“暂时”解耦**。





### 向channel发送数据的过程是怎样的？



### 从Channel读取数据的过程是怎样的？



### 从一个已关闭Channel仍能读出数据吗？





### Channel在什么情况下会引起内存泄漏？



### 关闭Channel会产生异常吗？





### 往一个关闭的Channel写入数据会发生什么？



## Select面试题

### select满足多个case的时候怎么执行的？











## Context面试题

### Context是什么？







### Context有什么作用？





### Context.Value的查找过程是怎样的？



### Context如何被取消？





## Interface面试题

### interface的底层原理？



### iface和eface的区别是什么？



### 8.两个interface可以比较吗？

```go
type Stu struct {
	Name string
}

type StuInt interface{}

func main() {
	var stu1, stu2 StuInt = &Stu{"Tom"}, &Stu{"Tom"}
	var stu3, stu4 StuInt = Stu{"Tom"}, Stu{"Tom"}
	// stu1 和 stu2 对应的类型是 *Stu，值是 Stu 结构体的地址，两个地址不同，因此结果为 false
	fmt.Println(stu1 == stu2) // false
	// stu3 和 stu4 对应的类型是 Stu，值是 Stu 结构体，且各字段相等，因此结果为 true
	fmt.Println(stu3 == stu4) // true
}
```

:::note

interface 的内部实现包含2个字段，类型 T 和值 V，2个 interface 可以比较。

2个interface相等有两种情况：

- 2个interface均等于 nil (此时 V 和 T 都处于 unset 状态)
- 类型T相同，且对应的值V相等

:::

### 7.Go中两个nil可能不相等吗?

**一个接口变量只有在其内部的 `(type, value)` 两个字段都为 `nil` 时，才等于 `nil`。**
如果接口保存了一个**类型type为 `*T` 的值，即使该value值是 `nil` 指针**，接口本身**也不等于 `nil`**。

在 Go 中，**接口（interface）在底层由两部分组成**（可以想象成一个结构体）：

```go
type iface struct {
    tab  *itab   // 类型信息（包含具体类型 T 和方法集）
    data unsafe.Pointer // 指向实际值的指针
}
```

- `tab`：记录**动态类型**（比如 `*int`, `map[string]int` 等）；
- `data`：记录**动态值**（比如某个 `*int` 指针的地址，即使它指向 `nil`）。

只有当 `tab == nil && data == nil` 时，接口才被认为是 `nil`。

```go
func main() {
	var p *int = nil      // p 是 *int 类型的 nil 指针
	var i interface{} = p // 把 p 赋值给接口 i
	
	fmt.Println(i == nil) // 输出: false
	fmt.Println(p == nil) // 输出: true
}
```

- `p` 是 `*int` 类型的 `nil` → `p == nil` 为 `true`；
- 但赋值给 `i` 后，`i` 的内部结构变成：
  - `type = *int`
  - `value = nil`（指针值为 nil）

- 因为 **类型不是 nil**（是 `*int`），所以 `i != nil`！

:::note

Go中两个nil可能不相等。

接口在底层由两部分组成：类型 T 和 值 V。一个接口变量等于 `nil`，**当且仅当它的类型T为 nil 且值V也为 nil**。两个接口值比较时，会先比较 T，再比较 V。 

比如一个`*int`的`nil`指针被赋值给接口变量，接口变量的类型T就是`*int`，值V是`nil`。

当将接口变量与真正的`nil`即 `(nil, nil)`进行比较时，因内部类型信息不一致，就会导致不相等。

:::

## 反射面试题







>www



::: note

这是一个笔记 Note 容器。

 :::

::: note 提醒 

这是一个笔记 Note 容器。

 :::



::: info
This is an info box.
:::

::: tip
This is a tip.
:::

::: warning
This is a warning.
:::

::: danger
This is a dangerous warning.

:::

::: details
This is a details block.
:::





::: danger STOP
危险区域，请勿继续
:::

::: details 点我查看代码
```js
console.log('Hello, VitePress!')
```
:::





- [x] 试试
- [x] 是是是
- [ ] 试试

```go
// 1. 两数之和
func main() {
	result := twoSum([]int{3, 3}, 6)
	fmt.Println(result)
}

func twoSum(nums []int, target int) []int {
	// 哈希表 key:数组中的值 value:值对应的数组索引
	hashMap := make(map[int]int) // 显式初始化哈希表（避免nil）
	// 遍历数组,获取需要的另一个数,如果map中存在这个数，则返回结果,否则将当前数加入map中
	for i, num := range nums {
		y := target - num // 需要的另一个数
		if _, ok := hashMap[y]; ok {
			// map中存在这个数，返回结果
			return []int{hashMap[y], i}
		}
		hashMap[num] = i // 记录当前值和在数组中的索引
	}
	return []int{} // 题目保证有解，返回空切片避免nil
}
```

**Teek 是一个轻量**、简洁高效、灵活配置、易于扩展的 **`VitePress`** 主题 ✨，是在默认主题的基础上进行拓展，支持 `VitePress` 的所有功能、配置，完全可以零成本迁移过来。

<!--滴答滴答滴答滴答-->

使用 Teek可以很方便的搭建一个结构化的知识库或博客。

::: warning

- Node.js `18.0.0` 及以上版本
- 在使用 Teek 前，要求至少会 VitePress 的基本使用和默认主题的基本配置，然后再查看本文档
- 本文档仅负责介绍 Teek 对 VitePress 默认主题的扩展部分，VitePress 自带配置请移步 [VitePress 中文文档](https://vitepress.dev/zh/)

:::



## 代码组



可以像这样对多个代码块进行分组：

::: code-group

```js [config.js]
/**
 * @type {import('vitepress').UserConfig}
 */
const config = {
  // ...
}

export default config
```

```ts [configddd.cs]
import type { UserConfig } from 'vitepress'

const config: UserConfig = {
  // ...
}

export default config
```

:::







## 特性

> **知识管理**

包含三种典型的知识管理形态：结构化、碎片化、体系化。轻松打造属于你自己的知识管理平台。

> **结构化 & 体系化**

自动生成侧边栏、目录页、索引页、面包屑等，轻松构建一个结构化知识库。

> **碎片化 & 个性化**

博客功能提供快速构建知识的碎片化形态，并提供大量个性化的主题配置。

> **文档风 & 博客风**

支持通过配置随意切换文档风和博客风，支持个人博客、文档站、知识库等场景。

## 拓展功能

相较于 VitePress 主题，Teek 主要实现了博客风格的功能，这些功能也兼容文档风格，您现在正在阅读的是 Teek 的文档风格。

> 全局

- 侧边栏自动生成，根据目录自动生成侧边栏，无需手动配置
- 提供目录页，根据 `Markdown` 文件路径自动生成目录
- 自动生成 `frontmatter`，并且支持拓展 `frontmatter` 格式
- 自动生成一级标题
- 全站背景图片
- `Markdown` 拓展：居中、居右容器、卡片容器、`Demo` 容器、`TODO` 列表、`Video` 容器
- 主题多元化：4 种布局模式、8 种主题风格选择，且支持自定义扩展新的主题风格
- 移动端适配：自动适配移动端
- ...

> 首页

- `Banner` 功能：提供 3 种风格选择：局部背景色、局部图片、全屏图片，提供打印个性签名、切换个性签名选择，提供 `Feature` 功能
- 文章列表：支持切换列表和卡片模式，展示文章标题、封面图、作者、创建时间、更新时间、标签、分类，且支持重写文章列表
- 博客卡片栏：博主信息栏、精选文章栏、分类栏、标签栏、友情链接栏、站点信息栏
- 全屏壁纸模式：只保留 `Banner` 背景图片或全站背景图片，且禁止滚动、打开开发者工具、右键功能
- 页脚：展示社交图标、版权信息、备案信息、自定义信息
- ...

> 文章页

- 文章信息：展示面包屑、作者、创建时间、更新时间、标签、分类、字数、阅读时长
- 评论区：提供 `Giscus`、`Twikoo`、`Waline`、`Artalk` 四种评论提供商选择，并且支持自定义评论区
- 代码块：UI 升级，支持一键折叠/展开
- 文章页风格书页化：提供 3 种风格选择：VitePress 原生、整体卡片化、片段卡片化
- 文章打赏：支持 3 种打赏风格选择
- 文章分享：提供一键复制文章链接功能
- 最近更新栏：展示最近更新文章
- ...

> 功能页

- 分类页
- 标签页
- 归档页
- 清单页
- 登录页
- 风险链接提示页

除了上述功能，Teek 也提供了各种 `CSS` 文件来增强 VitePress 的样式，并提供大量的插槽支持二次开发。

如果您是其他主题的用户，也可以按需引入 Teek 的功能，增强自己的站点风格。
